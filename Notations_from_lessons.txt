
print(1, 2, 3, sep='-', end=' finish\n')  - terminal :  1-2-3 finish

Типи даних :

    int   - integer
    float - float
    str   - string
    bool  - boo
    list  - list     - список/масив  - value = [1,2,3,4,5]
    dict  - dict     - словник       - value = {'key': 'value'}
    set   - set      - сет           - value = {1,2,3,4,5}
    tuple - tuple    - кортеж        - value = (1,2,3,4,5)
    None  - NoneType
    collection - ?

    Функції типів даних :
    isinstance(1, int)  - перевіряє чи перший аргумент належить до типу даних другого аргументу.
                          Повертає True/False

    Коментарі :
    *** можна конвертувати типи між собою : int - float , float-int , int - str, str-list і т.д.

Тернарки / Фішки

    num = int(input('Enter num: '))
    res = 'yes' if num > 5 else 'no'

########################################################################################################
list методи :
    array[0..n]   - виводить значення за вказаним індексом
         [-1..-n] - виводить значення за вказаним індексом(у зворотньому порядку)
    array.append(value)         - додає у список value (останнім)
    array.insert(index,value)   - додає у список value за index
    array.extend(array2)        - обєднує списки в один (array = array + array2)
    del array[n]                - видаляє елемент зі списку (n-індекс)
    array.remove(value)         - видалить елемент зі списку який має значення value
    array.pop(index)            - видаляє елемент по індексу (якщо не вказати - останній, повертає видалений елемент)
    array2 = array.copy() - копія списку (першого рівня.***вкладені списки не копіює , не глибоке копіювання)
    array.index(value,index from, index end) - повертає індекс значення.Можна вказати діапазон в якому шукати значення
    array.count(value)       - находить index значення value
    array.reverse()          - список у зворотньому порядку
    array.sort(reverse=True) - сортує наявний список , якщо вказати в агрументі reverse - сортує навпаки
    sum([1,2,3,4,5])         - повертає суму елементів списку
    min([6, 1, 2, 3, 4])     - шукає мін
    max([6, 1, 2, 3, 4])     - шукає макс
    sorted([2, 1, 3, 2, 1])               - сортує список , повертає новий список
    sorted([2, 1, 3, 2, 1], reverse=True) - сортує список(навпаки) , повертає новий список
    pow(25, 25)    - піднесення до степеня (25**25)
    array.clear()  - очищує список

    Фішки :
    array[::-2] - можна вказувати діапазон "зрізу" і крок (перших два аргументи - діапазон , другий - крок)
    list('Hello') - перетворить стрінгу на список.

    for i, item in enumerate(l):   - виведе індекс + значення через сепаратор "-"
        print(i, item, sep='-')

    l = [i for i in range(5)]      - сформує список від 0 до 4

    l = [1, 2, 3, 4, 5, 6, 7, 8]
    res = [i if i != 6 else 'ops' for i in l if i % 2 == 0]   => res=[2,4,7,8]
    *** записує парні числа і коли попадає на 6 , записує 6+1=7

    l = [
    [1, 2, 3, 4, 5, 6],
    [7, 8, 9, 10, 11, 12]
    ]
    res = [i for j in l for i in j]   => res[1,2,3,4,5,6,7,8,9,10,11,12]
    або
    res = []
    for j in l:
        for i in j:
            res.append(i)
################################################################################################
tuple методи :
    tuple.count(value)       - находить index значення value
    tuple.index(value,index from, index end) - повертає індекс значення.Можна вказати діапазон в якому шукати значення

################################################################################################
dict методи :
    user = {
        'name' : 'Vasya',
        'age'  : 22,
        'city' : 'Los angeles'
    }

    user['name']  - виведе значення по ключу 'name'

    for el in user :           - цикл , виведе ключ - значення кодного елементу
        print (el , user[el])    el  - ключ
    або так
    for key,value in users.items() :
        print(key,value)

    user.get('key', 55) - отримання значення за ключем, якщо такого ключа нема , поверне значення другого аргументу(55)
    del user[key]       - видалення значення за ключем
    pop = user.pop('key', 55) - видалить дані за ключем, поверне key. Другий параметр вказується для повернення 55
                                якщо такого ключа не буде і тоді не буде помилки програми.
    popitem = user.popitem()  - видалить останній елемент (key:value)  і поверне його кортежем
    user.clear()        - очищення обєкту
    copy = user.copy()  - копія (не глибока , першого рівня)
    user.items()        - поверне в масиві всі значення обєкта (key:value).
                          Щоб отримати повноцінний масив необхідно list(user.items())
    user.keys()         - отримання всіх ключів обєкта
    user.values()       - отримання всіх значень обєкта
    user.setdefault('age2', 25)      - ЯКЩО нема такої пари , створить нову , якщо є нічого не відбудеться.
    user.update({'street':'street'}) - додасть нову пару key:value
                                       або скорочено через пайпу
                                       user |= {'street': 'street'}
    Фішки :
    dict1 = {'NaMe': 'Max', 'aGe': 19}
    res = {k.lower(): v for k, v in dict1.items()} => res ={'name':'Max' ,'age':19}
    *** сформує новий dict та переведе key до нижнього регістру

################################################################################################
set методи :
    Це послідовність унікальних значень.
    Тобто , якщо є дубляжі set їх прибере.
    st='12312312'
    print(set(st))   => set {3,2,1}

    set1={1,2,3,4,5}
    set2={2,3,4}

    st.add(value)   - додає value до сету
    set1.issuperset(set2)  - перевіряє чи є елементи з set2 в set1. Повертає True/False
    set1.issubset(set2)    - перевіряє чи set1 є підсетом set2. Повертає True/False
    set1.isdisjoint(set2)  - перевіряє чи в сетах є спільні елементи. Повертає True якщо нема! False - якщо є!
    set1.union(set2)       - обєднання двох сетів в один. Повертає новий сет
    set1.intersection(set2) - створить новий сет з даними спільних елементів двох сетів
    set1.difference(set2)   - поверне сет в якому бутуть елементи яких немає в другому сеті
    set1.symmetric_difference(set2) - поверне сет з даними , елементи які неспівпали між двома сетами
    set1.update(set2)      - обєднає два сети. Додасть до першого другий.
    set1.remove(value)     - видалення value з сету. Якщо value нема в сеті - б"є помилку
    set1.discard(value)    - видалення value з сету. Якщо value нема в сеті - пропускає
    pop = set1.pop()       - видаляє випадковий елемент та повертає його

################################################################################################
string методи :

    st = '-'*20     => --------------------
    string = "Hello, my name is Max, I\"m 18 and my weight 70.5 kg" => екранізація спострофу \"

    name = 'Max'
    age = 18
    weight = 70.5

    string = "Hello, my name is Max, I`m 18 and my weight 70.5 kg"
    string = "Hello, my name is " + name + ", I`m " + str(age) + " and my weight " + str(weight) + " kg"
    string = "Hello, my name is %s, I`m %i and my weight %f kg" % (name, age, weight)
    string = "Hello, my name is {}, I`m {} and my weight {} kg".format(name, age, weight)
    string = "Hello, my name is {name}, I`m {age} and my weight {weight} kg".format(age=age, name=name, weight=weight)
    string = f"hello, my name is {name}, I`m {age} and my weight {weight} kg"

    string.index('n')     - пошук символу/стрічки. Повертає індекс. Якщо нема - бє помилку. Є дод. аргументи - діапазон пошуку
    string.find('leeeee') - пошук символу/стрічки. При находженні - повертає індекс, при відсутності -1
    string.count('l')     - порахує к-сть букв "l" в стрічці.
    string.capitalize()   - зробить в стрічці першу букву великою
    string.upper()        - зробить всі букви великі
    string.lower()        - зробить всі букви маленькі
    string.islower()      - поверне True/Fslse якщо всі літери в стрічці маленькі
    string.isupper()      - поверне True/Fslse якщо всі літери в стрічці великі
    'hello world'.title() - в кожному слові стрічки зробить першу букву великою
    'Hello World'.swapcase() - маленькі букви зробить великими , великі маленькими
    'asd'.isalpha()       - якщо в стрічці є букви - True , якщо поєднано з цифрами False
    '12s'.isdigit()       - перевіряє чи символ є цифрою , повертає True/False
    '12s '.isalnum()      - перевіряє чи в стрічці є букви і цифри. повертає True/False
    'hello'.startswith('e') - перевіряє чи починається стрічка на символ/групу символів , повертає True/False
    'hello'.endswith('lo')  - перевіряє чи закінчується стрічка на символ/групу символів , повертає True/False

    ['    aaaa         '.strip()]          - забирає всі пробіли які є мправа та зліва
    ['dd    aaaa         dd'.strip('d ')]  - забирає всі букви "d" та пробіли з права та зліва
    ['    aaaa         '.lstrip()]         - забирає всі пробіли з ліва
    ['    aaaa         '.rstrip()]         - забирає всі пробіли з права
    'hello world hello'.split(' ')         - роділить слова  в масив , сепаратор пробіл
    'hello-world-hello'.split('-')         - розділить слова в масив , сепаратор "-"
    'hello is hello'.partition('ll')       - розділить слова в масив на 3 частини , сепаратор 'll'

                                             *** => ('he', 'll', 'o is hello')
    l = ['hello', 'car', 'one'.]
    ('-'.join(l)                   - обєднує в одну стрічку по сепаратору
    '     '.isspace()              - перевіряє чи стрічка складається тільки з пробілів
    'hello world hello'.replace('l', 'L', 3) - замінить "l" на "L" але тільки 3 шт.

################################################################################################
def функції :

    def func2(a, b, c=3, *args, **kwargs):   a, b, c=3  - вхідні аргументи
        print(a + b + c)                     *args      - додаткові вхідні аргументи
        print(args)                          *args      - додаткові вхідні аргументи
        print(kwargs)                        **kwargs   - додаткові вхідні аргументи (перетворюються в dict)

              |a,b ,c|  *args    |   **kwargs       |
        func2(1, 2, 5, 3, 5, 6, 7, age=34, name='Max')

    l = [1, 2]
    def func(a, b):
        print(a, b)
    func(*l)         - розкладе масив l б на взідні аргументи ф-ї

################################################################################################
Деструктуризація :

    tuple1 = (1, 2, 3, 4, 5, 6)

    a, b, *_ = tuple1        => a=1,b=2
    _, a, _, b, *_ = tuple1  => a=2,b=4
    *_, a = tuple1           => a=6
------------------------------------------------------
    dog = {
    'name': 'Max',
    'age': 4
    }

    def func(name, age):
    print(name, age)

    func(**dog)     => ** розпаковує dict , якщо для dict вказати * - видасть ключі без значень
    dog2 = {**dog}
---------------------------------------------------------
    l = [1,2,3,4]

    def func(a,b,c,d):
    print(a, b, c, d)

    func(*l)            => розкладе список l на аргументи ф-ї

####################################################################################################

Декоратори   *** Робочий приклад ДИВИСЬ ДЗ урок №2

    def decor(func):                - decor приймає функцію як аргумент
        def inner(*args,**kwargs):  - у вхід. функ. можуть бути агр.,а можуть і не бути, на цей
            print('*' * 50)           вмпадок прописуємо *args та **kwargs
            func(*args, **kwargs)   - викликає вхідну функцію
            print('*' * 50)         - огортаємо її зірочами

        return inner

    @decor                          - викликаємо ф-ї decor  перед вхідною функцією
    @decor                          - decor  можемо викликати декілька разів
    def greeting(name):             - вхідна функція ( входить як аргумент в decor)
        print('Hello,', name)

    greeting('Max')

    inner = decor(greeting)         - варіанти виклику decor
    decor(greeting)()
    inner()
                                =>    *******************  - decor
                                      *******************
                                      Hello Max
                                      *******************
                                      *******************

########################################################################################################
Область видимості :

    print(globals())  - покаже глобальні змінні
    print(locals())   - покаже локальні змінні (використовувати в середині ф-й)
                        якщо написати команду на глобальному рівні - буде працювати як globals()
------------------------------------------------------------------------------------------------
    name2 = 'kokos'
    name = 'Max'              - глобальна змінна
    def a():
        name = 'Petia'        - локальна змінна (живе тільки в тілі ф-ї
        def b():
            #nonlocal name    - якщо прописати nonlocal змінна буде "жити" у всіх функціях рівнем вище.
            name = 'Alex'       без nonlocal => Max , Petia , Alex
            print(name)         з nonlocal   => Max , Alex , Alex  - відбулась заміна на всіх рівнях вище!
            #global name2     - якщо прописати global , можна змінювати змінну у ф-ї на глобальному рівні , але це діч!
            #name2 = Vasya      тепер name2 на глобальному рівні буде не 'kokos' a 'Vasya'
        b()
        print(name)

    print(name)
    a()
--------------------------------------------------------------------------------------------------
############################################################################################################
Замикання

    def counter():
        count = 0

        def inner():
            nonlocal count
            count += 1
            return count
    return inner

    c1 = counter()
    c2 = counter()

    print(c1())  => count=1
    print(c1())  => count=2

    print(c2())  => count=1
    print(c2())  => count=2

    print(c1())  => count=3
    print(c1())  => count=4
    print(c1())  => count=5
################################################################################################################
Lambda - схожа на стрілочну ф-ю в js. Може приймати значення. Використовується як метод або інфструкція (call-back)

    конструкція : lambda arg1,..argn : action(дія)

    func = lambda name,age: f'hello, {name} - {age}'
    print(func('Max', 15))
---------------------------------------------------------------------
    Сортування dict
    users = [
        {'name': 'max', 'age': 15},
        {'name': 'kira', 'age': 18},
        {'name': 'olha', 'age': 20},
        ]

    sort_by_age = lambda item : item['age']  - item обєкт з масиву
                                               і повертаємо з нього ключ 'age' -по якому будемо сортувати.

    users.sort(key=sort_by_age, reverse=True)  -викликаємо метод sort,  де прописуємо інструкцію lambda через key
    або так :
    users.sort(key=lambda item : item['age'], reverse=True)
    print(users)
---------------------------------------------------------------------
    Приклад використання lambda(інструкцій) в map та filter
    l = [1, 2, 3, 4]

    m = list(map(lambda x: x + 1, l))

    for i in m:
        print(i)

    for i in m:
        print(i)

    f = list(filter(lambda x: x % 2, l))
    print(f)

##########################################################################################################
Типізація ф-й , даних , створення нових типів

    def bbbb(st: str, b: int) -> int | str|list[int]:   - -> вказуємо типи даних які буде повертати ф-я
        print('pr')
        return [1,2,3]
    -------------------------------------------------------------------------------------------------
    l: list[int] = [] або [1, 'sss']                     - тут вказуємо який тип даних буде в списку

    Створення типу dict:
    from typing import NewType, Any, TypedDict
    User = TypedDict('User', {'name': str, 'age': int, 'status': bool}, total=False)
    total=False - дає можливість вводу не всіх ключів dict , або взагалі не вводити
                  Для прикладу :
                  задекларовано : {'name': str, 'age': int, 'status': bool}
                  створюю нову змінну : user: User = {'name': 'max', 'age': 13, 'status': True}
                  або вказую не всі ключі : user: User = {'name': 'max'}
                  або взагалі не вказую   : user: User = {}
    -------------------------------------------------------------------------------------------------
    def ddd(l: list[str]) -> tuple[str]:                - типізація з поверненням tuple
        return 'ddddd',
    -------------------------------------------------------------------------------------------------
    from typing import Callable  - використовуємо в тому випадку коли return буде повертати функцію.
                                   БІЛЬШ РОЗГОРНУТИЙ ВИПАДОК ДИВ В РІШЕННІ УРОКУ 2

    def counter() -> Callable[[], int]:        - Callable[[], int]
    count = 0                                    [] - перелічуємо якщо є вхідні аргументи : a:str,b:int
                                                 int  - який тип повертає callback ф-я
    def inner() -> int:
        nonlocal count
        # global count2
        count2 = 4
        count += 1
        return count

    return inner
    ------------------------------------------------------------------------------------------------
    Створення нового типу :
    from typing import NewType

    UserId = NewType('UserId', int)                     - декларація нового типу
    або так :
    MyType = int|str                                    - альтернатива

    def check(user_id: MyType або UserId):
        print(user_id)

    check('sss')
