
print(1, 2, 3, sep='-', end=' finish\n')  - terminal :  1-2-3 finish

Типи даних :

    int   - integer
    float - float
    str   - string
    bool  - boo
    list  - list     - список/масив  - value = [1,2,3,4,5]
    dict  - dict     - словник       - value = {'key': 'value'}
    set   - set      - сет           - value = {1,2,3,4,5}
    tuple - tuple    - кортеж        - value = (1,2,3,4,5)
    None  - NoneType
    collection - ?

    Функції типів даних :
    isinstance(1, int)  - перевіряє чи перший аргумент належить до типу даних другого аргументу.
                          Повертає True/False

    Коментарі :
    *** можна конвертувати типи між собою : int - float , float-int , int - str, str-list і т.д.

Тернарки / Фішки

    num = int(input('Enter num: '))
    res = 'yes' if num > 5 else 'no'

########################################################################################################
list методи :
    array[0..n]   - виводить значення за вказаним індексом
         [-1..-n] - виводить значення за вказаним індексом(у зворотньому порядку)
    array.append(value)         - додає у список value (останнім)
    array.insert(index,value)   - додає у список value за index
    array.extend(array2)        - обєднує списки в один (array = array + array2)
    del array[n]                - видаляє елемент зі списку (n-індекс)
    array.remove(value)         - видалить елемент зі списку який має значення value
    array.pop(index)            - видаляє елемент по індексу (якщо не вказати - останній, повертає видалений елемент)
    array2 = array.copy() - копія списку (першого рівня.***вкладені списки не копіює , не глибоке копіювання)
    array.index(value,index from, index end) - повертає індекс значення.Можна вказати діапазон в якому шукати значення
    array.count(value)       - находить index значення value
    array.reverse()          - список у зворотньому порядку
    array.sort(reverse=True) - сортує наявний список , якщо вказати в агрументі reverse - сортує навпаки
    sum([1,2,3,4,5])         - повертає суму елементів списку
    min([6, 1, 2, 3, 4])     - шукає мін
    max([6, 1, 2, 3, 4])     - шукає макс
    sorted([2, 1, 3, 2, 1])               - сортує список , повертає новий список
    sorted([2, 1, 3, 2, 1], reverse=True) - сортує список(навпаки) , повертає новий список
    pow(25, 25)    - піднесення до степеня (25**25)
    array.clear()  - очищує список

    Фішки :
    array[::-2] - можна вказувати діапазон "зрізу" і крок (перших два аргументи - діапазон , другий - крок)
    list('Hello') - перетворить стрінгу на список.

    for i, item in enumerate(l):   - виведе індекс + значення через сепаратор "-"
        print(i, item, sep='-')

    l = [i for i in range(5)]      - сформує список від 0 до 4

    l = [1, 2, 3, 4, 5, 6, 7, 8]
    res = [i if i != 6 else 'ops' for i in l if i % 2 == 0]   => res=[2,4,7,8]
    *** записує парні числа і коли попадає на 6 , записує 6+1=7

    l = [
    [1, 2, 3, 4, 5, 6],
    [7, 8, 9, 10, 11, 12]
    ]
    res = [i for j in l for i in j]   => res[1,2,3,4,5,6,7,8,9,10,11,12]
    або
    res = []
    for j in l:
        for i in j:
            res.append(i)
################################################################################################
tuple методи :
    tuple.count(value)       - находить index значення value
    tuple.index(value,index from, index end) - повертає індекс значення.Можна вказати діапазон в якому шукати значення

################################################################################################
dict методи :
    user = {
        'name' : 'Vasya',
        'age'  : 22,
        'city' : 'Los angeles'
    }

    user['name']  - виведе значення по ключу 'name'

    for el in user :           - цикл , виведе ключ - значення кодного елементу
        print (el , user[el])    el  - ключ
    або так
    for key,value in users.items() :
        print(key,value)

    setattr(user, k, v) - застовує нові атрибути key i value до обєкту, можна застосовувати в циклі , або окермою командою
                          for key,value in user.items() :
                              setattr(user, k, v)  - k , v нові значення
    user.get('key', 55) - отримання значення за ключем, якщо такого ключа нема , поверне значення другого аргументу(55)
    del user[key]       - видалення значення за ключем
    pop = user.pop('key', 55) - видалить дані за ключем, поверне key. Другий параметр вказується для повернення 55
                                якщо такого ключа не буде і тоді не буде помилки програми.
    popitem = user.popitem()  - видалить останній елемент (key:value)  і поверне його кортежем
    user.clear()        - очищення обєкту
    copy = user.copy()  - копія (не глибока , першого рівня)
    user.items()        - поверне в масиві всі значення обєкта (key:value).
                          Щоб отримати повноцінний масив необхідно list(user.items())
    user.keys()         - отримання всіх ключів обєкта
    user.values()       - отримання всіх значень обєкта
    user.setdefault('age2', 25)      - ЯКЩО нема такої пари , створить нову , якщо є нічого не відбудеться.
    user.update({'street':'street'}) - додасть нову пару key:value
                                       або скорочено через пайпу
                                       user |= {'street': 'street'}
    model_to_dict(value) - кнвертує value в dict , необхідно підключити бібліотеку
                           from django.forms import model_to_dict
    Фішки :
    dict1 = {'NaMe': 'Max', 'aGe': 19}
    res = {k.lower(): v for k, v in dict1.items()} => res ={'name':'Max' ,'age':19}
    *** сформує новий dict та переведе key до нижнього регістру

################################################################################################
set методи :
    Це послідовність унікальних значень.
    Тобто , якщо є дубляжі set їх прибере.
    st='12312312'
    print(set(st))   => set {3,2,1}

    set1={1,2,3,4,5}
    set2={2,3,4}

    st.add(value)   - додає value до сету
    set1.issuperset(set2)  - перевіряє чи є елементи з set2 в set1. Повертає True/False
    set1.issubset(set2)    - перевіряє чи set1 є підсетом set2. Повертає True/False
    set1.isdisjoint(set2)  - перевіряє чи в сетах є спільні елементи. Повертає True якщо нема! False - якщо є!
    set1.union(set2)       - обєднання двох сетів в один. Повертає новий сет
    set1.intersection(set2) - створить новий сет з даними спільних елементів двох сетів
    set1.difference(set2)   - поверне сет в якому бутуть елементи яких немає в другому сеті
    set1.symmetric_difference(set2) - поверне сет з даними , елементи які неспівпали між двома сетами
    set1.update(set2)      - обєднає два сети. Додасть до першого другий.
    set1.remove(value)     - видалення value з сету. Якщо value нема в сеті - б"є помилку
    set1.discard(value)    - видалення value з сету. Якщо value нема в сеті - пропускає
    pop = set1.pop()       - видаляє випадковий елемент та повертає його

################################################################################################
string методи :

    st = '-'*20     => --------------------
    string = "Hello, my name is Max, I\"m 18 and my weight 70.5 kg" => екранізація спострофу \"

    name = 'Max'
    age = 18
    weight = 70.5

    string = "Hello, my name is Max, I`m 18 and my weight 70.5 kg"
    string = "Hello, my name is " + name + ", I`m " + str(age) + " and my weight " + str(weight) + " kg"
    string = "Hello, my name is %s, I`m %i and my weight %f kg" % (name, age, weight)
    string = "Hello, my name is {}, I`m {} and my weight {} kg".format(name, age, weight)
    string = "Hello, my name is {name}, I`m {age} and my weight {weight} kg".format(age=age, name=name, weight=weight)
    string = f"hello, my name is {name}, I`m {age} and my weight {weight} kg"

    string.index('n')     - пошук символу/стрічки. Повертає індекс. Якщо нема - бє помилку. Є дод. аргументи - діапазон пошуку
    string.find('leeeee') - пошук символу/стрічки. При находженні - повертає індекс, при відсутності -1
    string.count('l')     - порахує к-сть букв "l" в стрічці.
    string.capitalize()   - зробить в стрічці першу букву великою
    string.upper()        - зробить всі букви великі
    string.lower()        - зробить всі букви маленькі
    string.islower()      - поверне True/Fslse якщо всі літери в стрічці маленькі
    string.isupper()      - поверне True/Fslse якщо всі літери в стрічці великі
    'hello world'.title() - в кожному слові стрічки зробить першу букву великою
    'Hello World'.swapcase() - маленькі букви зробить великими , великі маленькими
    'asd'.isalpha()       - якщо в стрічці є букви - True , якщо поєднано з цифрами False
    '12s'.isdigit()       - перевіряє чи символ є цифрою , повертає True/False
    '12s '.isalnum()      - перевіряє чи в стрічці є букви і цифри. повертає True/False
    'hello'.startswith('e') - перевіряє чи починається стрічка на символ/групу символів , повертає True/False
    'hello'.endswith('lo')  - перевіряє чи закінчується стрічка на символ/групу символів , повертає True/False

    ['    aaaa         '.strip()]          - забирає всі пробіли які є мправа та зліва
    ['dd    aaaa         dd'.strip('d ')]  - забирає всі букви "d" та пробіли з права та зліва
    ['    aaaa         '.lstrip()]         - забирає всі пробіли з ліва
    ['    aaaa         '.rstrip()]         - забирає всі пробіли з права
    'hello world hello'.split(' ')         - роділить слова  в масив , сепаратор пробіл
    'hello-world-hello'.split('-')         - розділить слова в масив , сепаратор "-"
    'hello is hello'.partition('ll')       - розділить слова в масив на 3 частини , сепаратор 'll'

                                             *** => ('he', 'll', 'o is hello')
    l = ['hello', 'car', 'one'.]
    ('-'.join(l)                   - обєднує в одну стрічку по сепаратору
    '     '.isspace()              - перевіряє чи стрічка складається тільки з пробілів
    'hello world hello'.replace('l', 'L', 3) - замінить "l" на "L" але тільки 3 шт.

################################################################################################
def функції :

    def func2(a, b, c=3, *args, **kwargs):   a, b, c=3  - вхідні аргументи
        print(a + b + c)                     *args      - додаткові вхідні аргументи
        print(args)                          *args      - додаткові вхідні аргументи
        print(kwargs)                        **kwargs   - додаткові вхідні аргументи (перетворюються в dict)

              |a,b ,c|  *args    |   **kwargs       |
        func2(1, 2, 5, 3, 5, 6, 7, age=34, name='Max')

    l = [1, 2]
    def func(a, b):
        print(a, b)
    func(*l)         - розкладе масив l б на взідні аргументи ф-ї

################################################################################################
Деструктуризація :

    tuple1 = (1, 2, 3, 4, 5, 6)

    a, b, *_ = tuple1        => a=1,b=2
    _, a, _, b, *_ = tuple1  => a=2,b=4
    *_, a = tuple1           => a=6
------------------------------------------------------
    dog = {
    'name': 'Max',
    'age': 4
    }

    def func(name, age):
    print(name, age)

    func(**dog)     => ** розпаковує dict , якщо для dict вказати * - видасть ключі без значень
    dog2 = {**dog}
---------------------------------------------------------
    l = [1,2,3,4]

    def func(a,b,c,d):
    print(a, b, c, d)

    func(*l)            => розкладе список l на аргументи ф-ї

####################################################################################################

Декоратори   *** Робочий приклад ДИВИСЬ ДЗ урок №2

    def decor(func):                - decor приймає функцію як аргумент
        def inner(*args,**kwargs):  - у вхід. функ. можуть бути агр.,а можуть і не бути, на цей
            print('*' * 50)           вмпадок прописуємо *args та **kwargs
            func(*args, **kwargs)   - викликає вхідну функцію
            print('*' * 50)         - огортаємо її зірочами

        return inner

    @decor                          - викликаємо ф-ї decor  перед вхідною функцією
    @decor                          - decor  можемо викликати декілька разів
    def greeting(name):             - вхідна функція ( входить як аргумент в decor)
        print('Hello,', name)

    greeting('Max')

    inner = decor(greeting)         - варіанти виклику decor
    decor(greeting)()
    inner()
                                =>    *******************  - decor
                                      *******************
                                      Hello Max
                                      *******************
                                      *******************


########################################################################################################
Область видимості :

    print(globals())  - покаже глобальні змінні
    print(locals())   - покаже локальні змінні (використовувати в середині ф-й)
                        якщо написати команду на глобальному рівні - буде працювати як globals()
------------------------------------------------------------------------------------------------
    name2 = 'kokos'
    name = 'Max'              - глобальна змінна
    def a():
        name = 'Petia'        - локальна змінна (живе тільки в тілі ф-ї
        def b():
            #nonlocal name    - якщо прописати nonlocal змінна буде "жити" у всіх функціях рівнем вище.
            name = 'Alex'       без nonlocal => Max , Petia , Alex
            print(name)         з nonlocal   => Max , Alex , Alex  - відбулась заміна на всіх рівнях вище!
            #global name2     - якщо прописати global , можна змінювати змінну у ф-ї на глобальному рівні , але це діч!
            #name2 = Vasya      тепер name2 на глобальному рівні буде не 'kokos' a 'Vasya'
        b()
        print(name)

    print(name)
    a()
--------------------------------------------------------------------------------------------------
############################################################################################################
Замикання

    def counter():
        count = 0

        def inner():
            nonlocal count
            count += 1
            return count
    return inner

    c1 = counter()
    c2 = counter()

    print(c1())  => count=1
    print(c1())  => count=2

    print(c2())  => count=1
    print(c2())  => count=2

    print(c1())  => count=3
    print(c1())  => count=4
    print(c1())  => count=5
################################################################################################################
Lambda - схожа на стрілочну ф-ю в js. Може приймати значення. Використовується як метод або інфструкція (call-back)

    конструкція : lambda arg1,..argn : action(дія)

    func = lambda name,age: f'hello, {name} - {age}'
    print(func('Max', 15))
---------------------------------------------------------------------
    Сортування dict
    users = [
        {'name': 'max', 'age': 15},
        {'name': 'kira', 'age': 18},
        {'name': 'olha', 'age': 20},
        ]

    sort_by_age = lambda item : item['age']  - item обєкт з масиву
                                               і повертаємо з нього ключ 'age' -по якому будемо сортувати.

    users.sort(key=sort_by_age, reverse=True)  -викликаємо метод sort,  де прописуємо інструкцію lambda через key
    або так :
    users.sort(key=lambda item : item['age'], reverse=True)
    print(users)
---------------------------------------------------------------------
    Приклад використання lambda(інструкцій) в map та filter
    l = [1, 2, 3, 4]

    m = list(map(lambda x: x + 1, l))

    for i in m:
        print(i)

    for i in m:
        print(i)

    f = list(filter(lambda x: x % 2, l))
    print(f)

##########################################################################################################
Типізація ф-й , даних , створення нових типів

    def bbbb(st: str, b: int) -> int | str|list[int]:   - -> вказуємо типи даних які буде повертати ф-я
        print('pr')
        return [1,2,3]
    -------------------------------------------------------------------------------------------------
    l: list[int] = [] або [1, 'sss']                     - тут вказуємо який тип даних буде в списку

    Створення типу dict:
    from typing import NewType, Any, TypedDict
    User = TypedDict('User', {'name': str, 'age': int, 'status': bool}, total=False)
    total=False - дає можливість вводу не всіх ключів dict , або взагалі не вводити
                  Для прикладу :
                  задекларовано : {'name': str, 'age': int, 'status': bool}
                  створюю нову змінну : user: User = {'name': 'max', 'age': 13, 'status': True}
                  або вказую не всі ключі : user: User = {'name': 'max'}
                  або взагалі не вказую   : user: User = {}
    -------------------------------------------------------------------------------------------------
    def ddd(l: list[str]) -> tuple[str]:                - типізація з поверненням tuple
        return 'ddddd',
    -------------------------------------------------------------------------------------------------
    from typing import Callable  - використовуємо в тому випадку коли return буде повертати функцію.
                                   БІЛЬШ РОЗГОРНУТИЙ ВИПАДОК ДИВ В РІШЕННІ УРОКУ 2

    def counter() -> Callable[[], int]:        - Callable[[], int]
    count = 0                                    [] - перелічуємо якщо є вхідні аргументи : a:str,b:int
                                                 int  - який тип повертає callback ф-я
    def inner() -> int:
        nonlocal count
        # global count2
        count2 = 4
        count += 1
        return count

    return inner
    ------------------------------------------------------------------------------------------------
    Створення нового типу :
    from typing import NewType

    UserId = NewType('UserId', int)                     - декларація нового типу
    або так :
    MyType = int|str                                    - альтернатива

    def check(user_id: MyType або UserId):
        print(user_id)

    check('sss')

#############################################################################################################
Clas / КЛАСИ :

    class User:

        count = 0                        => змінна класу , доступна всім підкласам

        __slots__ = ('_name', 'age')     => вказує які поля будуть в класі , після декларації - додати інші поля не можливо
                                            + економить память
        def __init__(self, name, age):
            self.__name = name           => приватна змінна (__name) - доступна тільки в області видимості декларованого класу.
            self._age = age              =>  приватна змінна (_name) - доступна в області видимості всіх підкласів і батьківсткого класу

        def __str__(self):               => "magic" метод , вказує яке буде відображення обєкту при виводі
            return f'{self.__name}, {self._age}'
            або    f'{self.__dict__}'    => представлення класу у форматі dict

    user = User('Max', 15)     => name:Max, age : 15   => екземпляр класу User
    user2 = User('Kira', 18)   => name:Kira, age : 18  => екземпляр класу User

    print(user.count)           => змінна батьківського класу відображається у всіх класах
    print(user2.count)          => змінна батьківського класу відображається у всіх класах
    print(user._name)           => звернення до приватних змінних
    print(user._User.__name)    => звернення до приватних змінних
    User.count = 16             => звернення до змінної батьківського класу відбувається через User
    user.count = 20             => якщо прописати так - створимо нове поле count в класі user.
                                   Якщо буде прописаний __slots__ - поле не створиться і видасть помилку
    del user.name               => Видалення поля в екземплярі класу user
    -----------------------------------------------------------------------------------------------------------
    НАСЛІДУВАННЯ класів :

    class User2(User):                  => User2 наслідує клас User
    def __init__(self, name, age):
        super().__init__(name, age)     => даний метод вказує що у класі User2 будуть ті самі поля що в User.

    def get_age(self):
        print(self._age)

    user2 = User2('Kira', 18)
    user2.get_age()
    --------------------------------------------------------------------------------------------------------------
    НАСЛІДУВАННЯ декількох класів : ВАЖЛИВО! Налідування класів можливе тільки при умові : 1 клас з методом __init__
                                    2. Всі наступні класи тільки з функціями без ініціалізації класу.
                                    Якщо в наслідуванні будуть класи з  __init__   - помилка.
    class Car:
        def __init__(self, brand):
            self.brand = brand

    class Greeting:
        def greeting(self):
            print(self.msg)

    class MyCar(Car, Greeting):                 => MyCar наслідує класи Car, Greeting
        def __init__(self, brand, seats):       => brand вказується як вхідний агрументи з класу Car, seats - як аргумент поточного класу MyCar
            super().__init__(brand)             => проходить наслідування ініціалізації по класу Car
            self.seats = seats

    car = MyCar('BMW', 5)             => 'BMW', 5
    car.greeting('Hello')             => 'Hello'
    print(car.brand)
    print(car.seats)
    ------------------------------------------------------------------------------------------------------------
    ІНКАПСУЛЯЦІЯ / ЗАМИКАННЯ / Property
    class User:
        def __init__(self, name):
            self.__name = name

        def __get_name(self):           =>  створюємо приватну ф-ю , доступну тільки в цьому класі
            return self.__name

        def __set_name(self, new_name): =>  створюємо приватну ф-ю , доступну тільки в цьому класі
            if new_name != 'Thir':
            self.__name = new_name

        def __del_name(self):           =>  створюємо приватну ф-ю , доступну тільки в цьому класі
            del self.__name

        name = property(fset=__set_na me, fget=__get_name, fdel=__del_name)

    АБО ОСЬ ТАК :

    class User:
        def __init__(self, name):
            self.__name = name

        @property
        def name(self):
            return self.__name

        @name.setter
        def name(self, new_name):
            if new_name != 'Thir':
                self.__name = new_name

        @name.deleter
        def name(self):
            del self.__name

    Приклади виклику :
    user = User('Max')
    print(user.name)
    user.name = 'Kira'
    print(user.name)
    del user.name
    print(user.name)
    print(user.get_name())
    user.set_name('Kira')
    print(user.get_name())
    user.del_name()
    print(user.get_name())
    -------------------------------------------------------------------------------------------------------------
    АБСТРАКТНІ КЛАСИ. Використовуються для контролю наслідувань всіх ф-й та методів. Тобто , якщо ми наслідуємо
    ф-ї з іншого класу , ми їх маємо прописати! Інакше працювати не буде.

    from abc import ABC, abstractmethod    => необхідно імпортувати для реалізації абстраутних класів
                                              Абстрактний обєкт , abstractmethod - декоратор.
                                              ABC - abstract base class
    class Shape(ABC):                      => створюємо асбстрактний клас

        @abstractmethod                    => ставимо маркери @abstractmethod для ф-й абстрактного класу
        def area(self):
            pass

        @abstractmethod                    => ставимо маркери @abstractmethod для ф-й абстрактного класу
        def perimeter(self):
            pass


    class Triangle(Shape):                    => наслідуємо абстрактний клас

        def __init__(self, a, b, c):          => ініціалізуємо аргументи
            self.a = a
            self.b = b
            self.c = c

        def area(self):                       => повторно прописуємо ф-ї з абстрактного класу. Якщо цього не зробити
            return self.a * self.b / self.c      наслідування не відбудеться і програма вибє помилку

        def perimeter(self):                  => повторно прописуємо ф-ї з абстрактного класу. Якщо цього не зробити
            return self.a + self.b + self.c      наслідування не відбудеться і програма вибє помилку

    АНАЛОГІЧНО РОБИМО З НАСТУПНОЮ Ф-Ю ЯКА НАСЛІДУЄ АБСТРАКТНИЙ КЛАС :

    class Rectangle(Shape):

        def __init__(self, a, b):
            self.a = a
            self.b = b

        def perimeter(self):
            return self.a * 2 + self.b * 2

        def area(self):
            return (self.a + self.b) * 2

    Методи виклику класів :
    shapes: list[Shape] = [Triangle(1, 2, 3), Rectangle(2, 3), Triangle(4, 5, 6)]

    for shape in shapes:
        print(shape.area())
        print(shape.perimeter())

    ----------------------------------------------------------------------------------------------------------
    ДЕКОРАТОРИ В КЛАСАХ : @staticmethod , @classmethod

    @staticmethod - використовується для ф-й які не працюють з вхідними даними/аргументами класу
    @classmethod  - використовується для роботи з даними класу
                    При використанні декоратора @classmethod ф-ї якими він декорується , автоматичного проставляється
                    аргумент cls, це означає що ми приймаємо батьківський клас і можемо викорситовувати все що в ньому є.
                    Див. приклад нижче

    class User:
        __count = 0

        def __init__(self, name, age):
            self.name = name
            self.age = age

        @staticmethod
        def greeting():
            print('Hello')

        @classmethod
        def get_count(cls):
            print(cls.__count)

        @classmethod
        def int_count(cls):
            cls.__count += 1

    User.greeting()
    user = User('Max', 15)
    User.greeting()
    User.int_count()
    User.int_count()
    User.int_count()
    User.get_count()
    -------------------------------------------------------------------------------------------------------
    Метод __new__
    В даному випадку (прикладі) виористовується для створення класу/класів з одинаковими даними.
    Тобто , створили user('Max',15) , потім  user2 ( 'Kira' , 21) , тепер вони всі будуть ( 'Kira' , 21)
    Як воно правильно працює ХЗ , не розібрався.

    class User:
        __instance = None

        def __new__(cls, *args, **kwargs):
            if not isinstance(cls.__instance, cls):
                cls.__instance = super().__new__(cls)
            return cls.__instance

        def __init__(self, name, age):
            self.name = name
            self.age = age


    user1 = User('Max', 15)
    user2 = User('Max', 15)
    user2.name='Kira'

    print(user1 is user2)
    print(id(user1))
    print(id(user2))

    user3 = object.__new__(User)    => а так створиться новий обєкт , з новими значеннями який не буде пересікатись зі старими.
    user3.name = 'Olha'
    user3.age = 3
    print(user1.name)
    print(user2.name)
    print(user3.name)
    -------------------------------------------------------------------------------------------------------------
    Використання класу як ф-ї

    class A:
        def __init__(self, value):
            self.value = value

        def __call__(self, inc):
            self.value += inc


    a = A(5)         => присвоюємо a клас A зі значенням 5
    a(6)             => в екземпляр класу a додаємо 6  яке додасться до 5
    print(a.value)
    -------------------------------------------------------------------------------------------------------------
    Операції над класами :

    class User:
     def __init__(self, name, age):
         self.name = name
         self.age = age

     def __str__(self):                   => представлення класу при виклику
         return f'{self.__dict__}'

     def __repr__(self):                  => також, представлення класу при виклику (якщо виводимо класи в масиві)
         return f'{self.__dict__}'           print ([class1,class2,...,classN]
         # return self.__str__()

     def __len__(self):                   => поверне довжину name
         return len(self.name)

     def __add__(self, other):            => додасть дані екземплярів класу
         return self.age + other.age

     def __sub__(self, other):            => віднімить дані екземплярів класу
         return self.age - other.age

     def __mul__(self, other):            => помножить дані екземплярів класу
         return self.age * other.age

     def __lt__(self, other):             => порівняє дані екземплярів класу
         return len(self.name) < len(other.name)

                                          *** ВАЖЛИВО! В ці математичні операції можна задавати будь-які дії : *,/,+ s  іт.д.
                                              необовязково що назва функці має відповідати метематичні операції.
    user = User('Max', 15)
    user2 = User('Olha', 15)
    print(user)

    print([user, User('Olha', 15)])

    print(len(user))
    print(user + user2)
    print(user - user2)
    print(user * user2)
    print(user<user2)
    ---------------------------------------------------------------------------------------------------------------
    Створення методів в класах

    class Array:
    length = 0

    def __init__(self, *args):
        self.__arr = [*args]
        Array.length = len(self.__arr)

    def __str__(self):
        return str(self.__arr)

    def __setitem__(self, key, value):
        self.__arr[key] = value

    def __getitem__(self, key):
        return self.__arr[key]

    def push(self, item):
        self.__arr.append(item)
        Array.length = len(self.__arr)

    def map(self, cb):
        return Array(*[cb(item) for item in self.__arr])

    def filter(self, cb):
        return Array(*[item for item in self.__arr if cb(item)])


    array = Array(1, 2, 3, 4)
    array[2] = 55
    print(array.length)
    print(array[0])
    array.push(88)
    print(array)
    print(type(array))
    array_map = array.map(lambda x: x * 3)
    print(type(array_map))
    print(array_map)

    map_filter = array_map.filter(lambda x: x % 2 == 0)

    print(map_filter)

    for i in Array(1, 2, 3, 4):
        print(i)

#############################################################################################################
DEBUGER / Дебагер

    1.  Потрібно поставити  мітку звідки запускати дебагер
        (навпроти необхідного рядкя мишкою клікнути по полю з ліва , має зявитись червона крпака)
    2.  Далі натиснути зверху на іконку "жука" - запустить дебагер
    3.  В низк відкриється віконечко дебагера , операції - F8 крок в перед , F7 - якщо на крокі функція - провалюється в неї і далі
        F8 - покроково. Якщо одразу нажати на ф-ї F8 він її виконає.

#############################################################################################################
TRY/EXPECT

    try:
        lksjflksjfd
    except NameError as err:     - можна відловлювати конкретні помилки - NameError
        print(str(err))

    print('sdfkhskdf')

    try:                   - можна  "ловити" деквлька помилок , але коли находить її всі наступні пропустить.
        print(100 /0)      - 1 помилка , на 0 ділити не можна
        while True:        - 2 помилка , безкінечний уикл , який необхідно перервати ctrl+c
            pass
        sdfsdfsf           - 3 помилка , невідоме імя змінної

    except ZeroDivisionError:             - системна назва 1 помилки
        print("На нуль ділити не можна")
    except NameError:                     - системна назва 2 помилки
        print("something wrong")
    except Exception as err:              - !!! ЯКЩО М И НЕ ЗНАЄМО НАЗВУ СИСТ. ПОМИЛКИ МОЖНА ЗАПИСАТИ ТАК !!!
        print("other expssssssssssssssssssssssssssssssssssssssssss")
    else:
        print("ok")                       - виконується після try/expect в будь-якому випадку
    finally:                              - виконується після try/expect в будь-якому випадку
        print("finish")
    print('sdfkhskdf')

#############################################################################################################
ГЕНЕРАТОРИ :

    l = [i for i in range(50000000)]  - просте наповнення списку даними
    input()                             ВЕЛИКИЙ МІНУС - одразу зїдає память (заповнює її створеними елеентами)

    g = (i for i in range(50000000))  - ГЕНЕРАТОР. Це інструкція яка виконується 1 один раз.
    print(type(g))                    - class <generator>

    for i in g:                       - виведе значення але не буде під них використовувати память
        print(i)

    Покрокоривий виклик генератора (next)

    print(next(g))                    - виведе 0
    print('sljdfhskjfhksjhfdjk')      - можна вставити будь-який свій код
    print(next(g))                    - виведе 1 , і можна так далі

    g = (i for i in range(5))
    print(next(g))
    print(next(g))
    print(next(g))
    print(next(g))
    print(next(g))
    print(next(g))                    - 6 елемента нема буде помилка (можна відловлювати try/expect

    users = [
        {"name": 'max', 'age': 15},
        {"name": 'Olha', 'age': 20},
        {"name": 'IWan', 'age': 25},
        {"name": 'Kira', 'age': 28},
        {"name": 'Kamila', 'age': 30},
    ]

    findUser = next((user for user in users if user['age'] == 45), None)    - можна одразу в змінну записати знайдене значення.
                                                                              інакше поверне "None" (якщо нема такого).
                                                                              По суті заміфна ф-ї "find"
    print(findUser)
    ------------------------------------------------------------------------------------------------
    yield  -  затримка виконання АЛЕ НЕ ЗАВЕРШЕННЯ!!!

    def gen(name: str):
        for ch in name:
            yield ch
            print("next")

    g = gen("Max")
    print(next(g))      - виведе : M
    print(next(g))      - виведе : M next a
    print(next(g))      - M next a next x
    print(next(g))      - M next a next x next
    print(type(g))      - StopIteration - треба відловлювати try/expect
    --------------------------------------------------
    Приклад 2

    def gen():
        yield 1
        yield 2
        yield 3
        return "sdfsdfsdf"

    g = gen()
    next(g)      - 1
    next(g)      - 2
    print(next(g))      - виведе в консоль 3

    try:                - відловлюємо на СИСТЕМНУ помилку StopIteration
        next(g)
    except StopIteration as err:
        print(err)

    -----------------------------------------------------------
    Приклад 3 . Генерація імен файлів , значень або назви за допом. yield

    def gen_jpeg_file_name():
        index = 1
        while True:
            yield f'file-{index}.jpeg'
            index += 1
    *** При кожному виклику ф-ї буде генеруватись назва файлу : file-1.jpeg, ... , file-n.jpeg
        Цикл While безкінечний  але його призупиняє yield і викидує з функції.
        Це типу проміжний return який не завершує функцію , а при повторому виклику переходить до наступного yield або команди

    def my_range(length):
        count = 0
        while count < length:
            yield count
            count += 1


    g = my_range(8)
    print(next(g))           - прикожному виклику через next буде виводити значення count яке буде збільшуватись на 1

################################################################################################################
File / Робота з файлами

    file = open('111.txt', 'r')     - артибути 'r' - тільки читання
                                               'w' - режим запису. !!! Якщо файлу нема - створить , якщо є - ПЕРЕЗАПИШЕ
                                                     З ВТРАТОЮ ІНФОРМАЦІЇ!!!
                                               'х' - створити новий файл
                                               'a' - додати у файл дані
                                               'r+' - читання файлу з можливістю запису
                                               'w+' - запис даних у файл + читання. !!! Якщо файлу нема - створить ,
                                                      якщо є - ПЕРЕЗАПИШЕ З ВТРАТОЮ ІНФОРМАЦІЇ!!!
                                               !!! Якщо невказувати атрибут , по замовчуванню буде 'r'

    file.close()       - по завершенню роботи з файлам ОБОВЯЗКОВО його закривати !!!

    file.read()        - читає повність весь зміст файлу
    file.readline()    - порядкове читання
    file.write('hi\n') - запис даних у файл. \n переведе на новий рядок
    file.writelines(['first\n', 'second\n'])    - запис декількох стрічок

    -------------------------------------------------------------------------------------------------------
    try/expect на відкриття файлу

    *** стара форма первірки на відкриття :
    try:
        file = open('111.txt', 'r')
        try:
            read = file.read()
            print(read)
        except Exception as err:
            print(err)

    *** нова форма з 'with'
    try:
        with open('111.txt', 'w') as file:
            print(file.read())
            ...                              - блок операцій з файлом (читання , запис і т.д.)
            ...                                це можна робити тут.
            ...                                file.close() - тут використовувати не обовязково with його сам закриє по завершенню блоку

    except Exception as err:
        print(err)

    ----------------------------------------------------------------------------------------------------------
    JSON / Запис - Читання у файл

    import json                                 -  підключення бібліотеки

    user = {"name": "max", "age": 15}

    try:                                        - записуємо у файл user  у форматі json
        with open('users.json', 'w') as file:
        json.dump(user, file)

    except Exception as err:
        print(err)

    try:                                        - читаємо json стрічку з файлу і переводимо її у dict
        with open('users.json') as file:
            user = json.load(file)
            print(user['age'])

    except Exception as err:
        print(err)

    ------------------------------------------------------------------------------------------------------------
    PICKLE  - запис даних в бінарному коді , записувати можна будь що , навіть ф-ю def

    import pickle

    def show():
        print('hello')

    try:
        with open('users.db', 'wb') as file:    - записуємо 'wb'у файл users.db , якщо його нема - створить
        pickle.dump(show, file)                 - записуємо ф-ю def show()

    except Exception as err:
        print(err)

    try:
        with open('users.db', 'rb') as file:    - читаємо з файлу бінарний код (в даному випадку була передана функція def show())
            a = pickle.load(file)               - отримуємо функцію def show()
            a()                                 - викликаємо def show()

    except Exception as err:
        print(err)

    ------------------------------------------------------------------------------------------------------------
    PRINT - запис у файл

    try:
        with open('test.txt', 'w') as file:
            print('Hello1', file=file)
            print('Hello2', file=file)
            print('Hello3', file=file)
    except Exception as err:
    print(err)

######################################################################################################################

    MATCH  (switch/case js)

    choice = input('Enter num: ')       - приклад класичного (switch/case js)

    match choice:
        case '1':
            print(1)
        case '2':
            print(2)
        case _:
            print('default')

    -------------------------------------------------------------------------------------------------------
    Другий приклад.
    Використання match з даними зі списку

    p = ['left', '200', 33]            - список

    match p:
        case 'left' as action, value:               - якщо пергий елемент 'left' , тоді ми зчитуємо 'left' та "200" (action, value)
            print(f'{action=} {value=}')

        case 'left'|'top' as action, value, other:  - якщо пергий елемент 'left' або другий 'top' , тоді ми
            print(action, value, other)               зчитуємо 'left',"200","33" (action, value, other)

        case _:                                     - якщо в списку не буде жодного значення яке ми шукаємо - видасть default
            print("default")

    ----------------------------------------------------------------------------------------------------------
    Використання matc у ф-ях :

    karina = {"name": "Karina", "age": 5}
    max = User("Max", 3)

    def matcher(item: User | dict):         - вказуємо що приймаємо як аргумент dict або class
        match item:                         - matc САМ перевірить до якого типу відноситься агрумент і підбере case
                                              В саse можна поставити ще додаткові умови відбору : по іменам , віку , будь-чому

            case User(name='Max' | 'olha' as name, age=3 | 16 | 18 as age) if len(name) != age:
                print(name, age)
            case {'age': int(age)} if age in range(1, 6):
                print(age)
            case _:
                print('default')

    matcher(karina)

########################################################################################################################
Бібліотека os

import os

    print(os.uname())           - виводить інформацію про операційну систему
    print(os.environ)           - показує змінні системи
    os.system('htop')           - можна запускати коменди операційної системи

    print(os.getcwd())          - відобразить поточний шлях файлу який ми запускаємо C:\Users\glili\PycharmProjects\pythonProject
    os.mkdir('first')           - створить директорію в поточній папці
    os.mkdir('second')          - аналогічно

    -------------------------------------------------------------------------------------------------------
    c:\folder1\folder2\         - відображення шляху на відновся
         /folder1/folder2       - відображення шляху на лінокс
    path = os.path.join('folder1', 'folder2', '111.txt')    - path відобразить правильно шлях враховуючи систему на якій він запускається
    print(path)
    -------------------------------------------------------------------------------------------------------

    for root, folders, files in os.walk('.'):       - walk дозволяє показати папки та файли в директорії
        print(f'{root=} {folders=} {files=}')         walk('.')  - поточна директорія

    os.rename('os_test.py', 'os_test2.py')                           - перейменування файлу
    os.rename('os_test2.py', os.path.join('first', 'os_test.py'))    - переміщення файлу в папку first і перейменування його на os_test.py